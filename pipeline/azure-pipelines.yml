trigger:
  branches:
    include:
      - main
      - feature/*

pool:
  vmImage: 'ubuntu-latest'
  # name: 'AgentPool-09NOV2025'

resources:
  repositories:
    - repository: org-devops-scripts
      type: git
      name: CloudProject1.0/org-devops-scripts   # Azure DevOps project/repo
      ref: refs/heads/main

parameters:
  - name: environment
    displayName: ENVIRONMENT
    type: string
    default: dev
    values:
      - dev
      - staging

  - name: run_sonar_scan
    displayName: Run Sonar Scan?
    type: string
    default: no
    values:
      - yes
      - no
    
  - name: run_infracost
    displayName: Run Infracost Scan?
    type: string
    default: no
    values:
      - yes
      - no

  - name: run_terratest
    displayName: Run Terratest?
    type: string
    default: no
    values:
      - yes
      - no

  - name: run_tflint
    displayName: Run TFLint?
    type: string
    default: yes
    values:
      - yes
      - no

  - name: run_trivy
    displayName: Run Trivy?
    type: string
    default: no
    values:
      - yes
      - no

variables:
- name: varServiceConnection
  value: SC-04JAN2026

- name: varbackendAzureRmResourceGroupName
  value: ankurbackend01

- name: varbackendAzureRmStorageAccountName
  value: ankur01storage01ae01

# Selected values based on parameter: dev or staging
- name: selected_service_connection
  value: ${{ variables.varServiceConnection }}

- name: mainRepoRoot
  value: '$(Build.SourcesDirectory)/infra'

- ${{ if eq(parameters.environment, 'dev') }}:
  - group: Project03-VariableGroup-Dev
  - name: varWorkingDirectory
    value: '$(System.DefaultWorkingDirectory)/infra/dev'

- ${{ if eq(parameters.environment, 'staging') }}:
  - group: Project03-VariableGroup-Staging
  - name: varWorkingDirectory
    value: '$(System.DefaultWorkingDirectory)/infra/staging'


stages:
# =====================================
# Main branch flow
# =====================================
# Stage: terraform install > terraform init
- stage: MainBranchMerge_TerraformInit
  displayName: "Branch: (main) - Stage: Terraform Init"
  condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
  jobs:
  - job: Main_Init
    steps:
    # TEMPLATE --> Terraform INSTALL & INIT
    - template: templates/terraform-init.yml
      parameters:
        workingDirectory: ${{ variables.varWorkingDirectory }}
        serviceConnection: ${{ variables.varServiceConnection }}
        backendRg: ${{ variables.varbackendAzureRmResourceGroupName }}
        backendStorage: ${{ variables.varbackendAzureRmStorageAccountName }}
        backendContainer: $(selectedVG_varbackendAzureRmContainerName)
        backendKey: $(selectedVG_varbackendAzureRmKey)

# Stage: Manual Validation > terraform install > terraform init > terraform plan
- stage: MainBranchMerge_Approval
  displayName: "Branch: (main) - Stage: Approval"
  dependsOn: MainBranchMerge_TerraformInit
  condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
  jobs:
  - job: Main_Approval_Init_Plan
    pool: server   # âœ… REQUIRED for ManualValidation
    steps:
    # Manual Validation
    - task: ManualValidation@0
      inputs:
        notifyUsers: 'ankur@example.com'
        instructions: 'Approve to proceed with Terraform Plan for main branch.'

# Stage: Manual Validation > terraform install > terraform init > terraform plan
- stage: MainBranchMerge_TerraformInitPlan
  displayName: "Branch: (main) - Stage: Init, Plan"
  dependsOn: MainBranchMerge_Approval
  condition: and(succeeded('MainBranchMerge_Approval'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: Main_Init_Plan
    steps:
    # ðŸ” Fetch secrets FIRST
    - task: AzureKeyVault@2
      displayName: "Fetch secrets from Azure Key Vault"
      inputs:
        azureSubscription: ${{ variables.varServiceConnection }}
        KeyVaultName: ankurKeyVault3
        SecretsFilter: INFRACOSTAPIKEYVAULT
        RunAsPreJob: true
    # ðŸ§ª Validate secret
    - script: |
        if [ -z "$(INFRACOSTAPIKEYVAULT)" ]; then
          echo "âŒ INFRACOST_API_KEY not loaded"
          exit 1
        else
          echo "âœ… INFRACOST_API_KEY loaded"
        fi
      displayName: "Validate Infracost Secret"

    # TEMPLATE --> Terraform INSTALL & INIT & PLAN
    - template: templates/terraform-plan.yml
      parameters:
        workingDirectory: ${{ variables.varWorkingDirectory }}
        serviceConnection: ${{ variables.varServiceConnection }}
        backendRg: ${{ variables.varbackendAzureRmResourceGroupName }}
        backendStorage: ${{ variables.varbackendAzureRmStorageAccountName }}
        backendContainer: $(selectedVG_varbackendAzureRmContainerName)
        backendKey: $(selectedVG_varbackendAzureRmKey)

    # Install Infracost
    - script: |
        echo "Installing Infracost..."
        curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh

        echo "Configuring API Key..."
        infracost configure set api_key $(INFRACOSTAPIKEYVAULT)

        infracost --version
      displayName: "Install & Configure Infracost"

    # Run Infracost Breakdown
    - script: |
        echo "Running Infracost breakdown..."
        cd ${{ variables.varWorkingDirectory }}

        timestamp=$(date +"%Y-%m-%d-%H-%M-%S")
        build_number=$(Build.BuildNumber)
        INFRACOST_JSON_FILE="infracost-report-${build_number}-${timestamp}.json"

        echo "Executing: infracost breakdown --path=. --format json --out-file $INFRACOST_JSON_FILE"
        infracost breakdown \
            --path . \
            --format json \
            --out-file "$INFRACOST_JSON_FILE" || true

        echo "Verifying Infracost report..."
        if [ -f "$INFRACOST_JSON_FILE" ]; then
          echo "âœ… Infracost report generated successfully"
          infracost upload --path "$INFRACOST_JSON_FILE"
          echo "âœ… Infracost report uploaded successfully"
        else
          echo "âŒ Infracost did NOT generate a report!"
          echo "{}" > "$INFRACOST_JSON_FILE"
        fi

        ls -l "$INFRACOST_JSON_FILE"
      displayName: "Run Infracost Cost Breakdown"

    # Check and Copy Infracost Report
    - script: |
        echo "Checking for Infracost report before publishing..."
        if [ -f "${{ variables.varWorkingDirectory }}/$INFRACOST_JSON_FILE" ]; then
          echo "âœ… Infracost report found, ready for publish."
        else
          echo "âš ï¸ No Infracost report found at ${{ variables.varWorkingDirectory }}/$INFRACOST_JSON_FILE"
          echo "{}" > ${{ variables.varWorkingDirectory }}/$INFRACOST_JSON_FILE
        fi
      displayName: "Verify Infracost Report File"

    # Publish Infracost Report (same pattern as Trivy)
    - publish: ${{ variables.varWorkingDirectory }}/INFRACOST_JSON_FILE
      artifact: "$(INFRACOST_JSON_FILE)"
      displayName: "Publish Infracost Report"

# =====================================
# Feature branch flow
# =====================================

# Stage: terraform install > terraform init > terraform validate
- stage: FeatureBranchMerge_TerraformInitValidate
  displayName: "Branch: (feature) - Stage: Terraform Init, Validate"
  # dependsOn: FeatureBranchMerge_TerraformInit
  condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
  jobs:
  - job: Feature_Init_Validate
    steps:

    # TEMPLATE --> Terraform INSTALL & INIT & VALIDATE
    - template: templates/terraform-validate.yml
      parameters:
        workingDirectory: ${{ variables.varWorkingDirectory }}
        serviceConnection: ${{ variables.varServiceConnection }}
        backendRg: ${{ variables.varbackendAzureRmResourceGroupName }}
        backendStorage: ${{ variables.varbackendAzureRmStorageAccountName }}
        backendContainer: $(selectedVG_varbackendAzureRmContainerName)
        backendKey: $(selectedVG_varbackendAzureRmKey)

- stage: FeatureBranch_SonarQube
  displayName: "Branch: (feature) - Stage: SonarQube Scan"
  dependsOn: FeatureBranchMerge_TerraformInitValidate
  condition: and(
      startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'),
      eq('${{ parameters.run_sonar_scan }}', 'yes')
    )
  jobs:
  - job: SonarQubeScan
    displayName: "Run SonarQube Scan"
    pool:
      name: 'Default'
    steps:
    # 1ï¸âƒ£ Prepare SonarQube (uses sonar-project.properties automatically)
    - checkout: self

    - powershell: |
        sonar-scanner -D sonar.login=$(SONAR_TOKEN)
      displayName: "Run sonar-scanner"

- stage: FeatureBranch_TerraTest
  displayName: "Branch: (feature) - Stage: TerraTest"
  dependsOn: FeatureBranchMerge_TerraformInitValidate
  condition: and(
      startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'),
      eq('${{ parameters.run_terratest }}', 'yes')
    )
  jobs:
  - job: TerratestJob
    displayName: "Run TerraTest Scan"
    pool:
      name: 'Default'
    steps:
    # 1ï¸âƒ£ Prepare TerraTest
    - checkout: self

    - powershell: |
        cd .\terratest
        go test -v -timeout 45m .\unittest2_test.go
      displayName: "Run TerraTest scan"

- stage: FeatureBranchMerge_TFLintScan
  displayName: "Stage: TFLint Scan"
  dependsOn: FeatureBranchMerge_TerraformInitValidate
  condition: and(
      startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'),
      eq('${{ parameters.run_tflint }}', 'yes')
    )
  jobs:
  - job: LintAndSecurity_TFLint
    displayName: "Run TFLint"
    pool:
      vmImage: 'ubuntu-latest'
    steps:

    # Checkout code
    - checkout: self
    - checkout: org-devops-scripts

    # Install TFLint
    - script: |
        echo "Installing TFLint..."
        curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash
        tflint --version
      displayName: "Install TFLint"

    # Run TFLint
    - script: |
        echo "Running TFLint..."
        cd ${{ variables.varWorkingDirectory }}
        tflint --init
        tflint --recursive --enable-rule=terraform_required_providers --force
      displayName: "Run TFLint Analysis"

    # Generate JSON Report
    - script: |
        echo "Generating TFLint JSON report..."

        echo "Current directory:"
        pwd
        ls -la

        cd ${{ variables.varWorkingDirectory }} || {
          echo "âŒ Working directory does not exist"
          exit 1
        }

        tflint --format json > $(System.DefaultWorkingDirectory)/tflint-report.json || true

        echo "âœ… TFLint report generated at:"
        ls -l $(System.DefaultWorkingDirectory)/tflint-report.json
      displayName: "Generate TFLint Report"

    # # Generate JSON Report
    # - script: |
    #     cd ${{ variables.varWorkingDirectory }}
    #     echo "Generating TFLint JSON report..."

    #     tflint --format json > tflint-report.json
    #     mv tflint-report.json $(System.DefaultWorkingDirectory)/tflint-report.json
    #   displayName: "Generate TFLint Report"

    - script: |
        python --version
        which python
      displayName: "Verify Python Runtime"

    # Fail pipeline if TFLint reports HIGH/CRITICAL issues
    - script: |
        echo "ðŸ“Š Running TFLint summary & policy enforcement..."
        python $(Build.SourcesDirectory)/org-devops-scripts/tflint/tflint_summary.py \
          $(System.DefaultWorkingDirectory)/tflint-report.json
      displayName: "TFLint Summary & Policy Enforcement"

    # Publish Report Artifact
    - publish: $(System.DefaultWorkingDirectory)/tflint-report.json
      artifact: TFLintReport_${{ parameters.environment }}

- stage: FeatureBranchMerge_TrivyScan
  displayName: "Stage: Trivy Scan"
  dependsOn: FeatureBranchMerge_TerraformInitValidate
  condition: and(
      startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'),
      eq('${{ parameters.run_trivy }}', 'yes')
    )
  jobs:
  - job: LintAndSecurity_Trivy
    displayName: "Run Trivy scan"
    pool:
      vmImage: 'ubuntu-latest'
    steps:

    # Install Trivy (Official APT Method)
    - script: |
        echo "Installing Trivy..."
        sudo apt-get update -y
        sudo apt-get install -y wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
        sudo apt-get update -y
        sudo apt-get install -y trivy
        trivy --version
      displayName: "Install Trivy"

    # Run Trivy Terraform Config Scan
    - script: |
        echo "Running Trivy Terraform config scan..."
        cd ${{ variables.varWorkingDirectory }}

        echo "Executing: trivy config . --format json --output trivy-report.json"
        trivy config . \
            --format json \
            --severity HIGH,CRITICAL \
            --output trivy-report.json || true

        echo "Verifying Trivy report..."
        if [ -f trivy-report.json ]; then
            echo "âœ… Trivy report generated successfully"
        else
            echo "âŒ Trivy did NOT generate a report!"
            echo "{}" > trivy-report.json
        fi

        ls -l trivy-report.json
      displayName: "Run Trivy Config Scan (v0.67.2 Compatible)"

    # Check and copy Trivy report to known location
    - script: |
        echo "Checking for Trivy report before publishing..."
        if [ -f "${{ variables.varWorkingDirectory }}/trivy-report.json" ]; then
          echo "âœ… Trivy report found, ready for publish."
        else
          echo "âš ï¸ No Trivy report found at ${{ variables.varWorkingDirectory }}/trivy-report.json"
          echo "{}" > ${{ variables.varWorkingDirectory }}/trivy-report.json
        fi
      displayName: "Verify Trivy Report File"

    # Publish Trivy Report
    - publish: ${{ variables.varWorkingDirectory }}/trivy-report.json
      artifact: TrivyReport_${{ parameters.environment }}
      displayName: "Publish Trivy Report"

    # Fail pipeline if Trivy finds more than 1 HIGH or CRITICAL issue
    - script: |
        echo "ðŸ” Checking Trivy report for misconfigurations..."

        REPORT="${{ variables.varWorkingDirectory }}/trivy-report.json"

        if [ ! -f "$REPORT" ]; then
          echo "âŒ Trivy report not found! Failing pipeline."
          exit 1
        fi

        echo "ðŸ“„ Parsing Trivy JSON..."

        FAILURES=$(jq -r '.Results[].MisconfSummary.Failures' "$REPORT")

        echo "ðŸŸ¥ Total Failures: $FAILURES"

        # Fail pipeline if FAILURES > 1
        if [ "$FAILURES" -gt 1 ]; then
          echo "âŒ Pipeline FAILED â€” More than 1 Trivy failure detected."
          exit 1
        fi

        echo "âœ… Trivy scan passed within allowed thresholds."
      displayName: "âŒ Fail Pipeline if Trivy Failures > 1"
      condition: succeededOrFailed()

- stage: FeatureBranch_CostPlan_Approval
  displayName: "Branch: (feature) - Stage: Approval before Fmt (feature)"
  dependsOn: FeatureBranchMerge_TerraformInitValidate
  condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
  jobs:
  - job: Feature_Approval
    pool: server   # âœ… REQUIRED for ManualValidation
    steps:
    - task: ManualValidation@0
      inputs:
        notifyUsers: 'ankur@example.com'
        instructions: 'Approve to run Terraform Fmt on feature branch.'

# Stage: Manual Validation > terraform install > terraform init > terraform plan
- stage: FeatureBranchMerge_TerraformInitPlan_InfraCost
  displayName: "Branch: (feature) - Stage: Init, Plan - Infra Cost"
  dependsOn: FeatureBranch_CostPlan_Approval
  condition: and(
      succeeded('FeatureBranch_CostPlan_Approval'),
      startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
    )
  jobs:
  - job: FeatureInitPlan_InfraCost
    displayName: "Run Init, Plan, Infra Cost"
    steps:

    # ðŸ” Fetch secrets FIRST
    - task: AzureKeyVault@2
      displayName: "Fetch secrets from Azure Key Vault"
      condition: eq('${{ parameters.run_infracost }}', 'yes')
      inputs:
        azureSubscription: ${{ variables.varServiceConnection }}
        KeyVaultName: ankurKeyVault3
        SecretsFilter: INFRACOSTAPIKEYVAULT
        RunAsPreJob: true
    
    # ðŸ§ª Validate secret
    - script: |
        if [ -z "$(INFRACOSTAPIKEYVAULT)" ]; then
          echo "âŒ INFRACOST_API_KEY not loaded"
          exit 1
        else
          echo "âœ… INFRACOST_API_KEY loaded"
        fi
      displayName: "Validate Infracost Secret"
      condition: eq('${{ parameters.run_infracost }}', 'yes')

    # TEMPLATE --> Terraform INSTALL & INIT & PLAN
    - template: templates/terraform-plan.yml
      parameters:
        workingDirectory: ${{ variables.varWorkingDirectory }}
        serviceConnection: ${{ variables.varServiceConnection }}
        backendRg: ${{ variables.varbackendAzureRmResourceGroupName }}
        backendStorage: ${{ variables.varbackendAzureRmStorageAccountName }}
        backendContainer: $(selectedVG_varbackendAzureRmContainerName)
        backendKey: $(selectedVG_varbackendAzureRmKey)

    # Install Infracost
    - script: |
        echo "Installing Infracost..."
        curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh

        echo "Configuring API Key..."
        infracost configure set api_key $(INFRACOSTAPIKEYVAULT)

        infracost --version
      displayName: "Install & Configure Infracost"
      condition: eq('${{ parameters.run_infracost }}', 'yes')

    # Run Infracost Breakdown
    - script: |
        echo "Running Infracost breakdown..."
        cd ${{ variables.varWorkingDirectory }}

        timestamp=$(date +"%Y-%m-%d-%H-%M-%S")
        build_number=$(Build.BuildNumber)
        INFRACOST_JSON_FILE="infracost-report-${build_number}-${timestamp}.json"
        echo "##vso[task.setvariable variable=INFRACOST_JSON_FILE]$INFRACOST_JSON_FILE"
        
        echo "Executing: infracost breakdown --path=. --format json --out-file $INFRACOST_JSON_FILE"
        infracost breakdown \
            --path . \
            --format json \
            --out-file "$INFRACOST_JSON_FILE" || true

        echo "Verifying Infracost report..."
        if [ -f "$INFRACOST_JSON_FILE" ]; then
          echo "âœ… Infracost report generated successfully"
          infracost upload --path "$INFRACOST_JSON_FILE"
          echo "âœ… Infracost report uploaded successfully"
        else
          echo "âŒ Infracost did NOT generate a report!"
          echo "{}" > "$INFRACOST_JSON_FILE"
        fi

        ls -l "$INFRACOST_JSON_FILE"
      displayName: "Run Infracost Cost Breakdown"
      condition: eq('${{ parameters.run_infracost }}', 'yes')

    # Check and Copy Infracost Report
    - script: |
        echo "Checking for Infracost report before publishing..."
        echo "Checking Infracost report at: "
        echo "Checking all files at: "
        echo ${{ variables.varWorkingDirectory }}
        ls -l
        if [ -f "${{ variables.varWorkingDirectory }}/$(INFRACOST_JSON_FILE)" ]; then
          echo "âœ… Infracost report found, ready for publish."
        else
          echo "âš ï¸ No Infracost report found at ${{ variables.varWorkingDirectory }}/$(INFRACOST_JSON_FILE)"
          echo "{}" > ${{ variables.varWorkingDirectory }}/$(INFRACOST_JSON_FILE)
        fi
      displayName: "Verify Infracost Report File"
      condition: eq('${{ parameters.run_infracost }}', 'yes')

    # Publish Infracost Report (same pattern as Trivy)
    - publish: ${{ variables.varWorkingDirectory }}/$(INFRACOST_JSON_FILE)
      artifact: $(INFRACOST_JSON_FILE)
      displayName: "Publish Infracost Report"
      condition: eq('${{ parameters.run_infracost }}', 'yes')

- stage: FeatureBranch_Apply_Approval
  displayName: "Branch: (feature) - Stage: Approval before Fmt (feature)"
  dependsOn: FeatureBranchMerge_TerraformInitPlan_InfraCost
  condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
  jobs:
  - job: Feature_Approval
    pool: server   # âœ… REQUIRED for ManualValidation
    steps:
    - task: ManualValidation@0
      inputs:
        notifyUsers: 'ankur@example.com'
        instructions: 'Approve to run Terraform Fmt on feature branch.'

# Stage: terraform install > terraform init > terraform apply
- stage: FeatureBranchMerge_TerraformInitApply
  displayName: "Branch: (feature) - Stage: Terraform Init, Apply"
  dependsOn: FeatureBranch_Apply_Approval
  condition: and(succeeded('FeatureBranch_Apply_Approval'), startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'))
  jobs:
  - job: Feature_Init_Apply
    steps:

    # TEMPLATE --> Terraform INSTALL & INIT & APPLY
    - template: templates/terraform-apply.yml
      parameters:
        workingDirectory: ${{ variables.varWorkingDirectory }}
        serviceConnection: ${{ variables.varServiceConnection }}
        backendRg: ${{ variables.varbackendAzureRmResourceGroupName }}
        backendStorage: ${{ variables.varbackendAzureRmStorageAccountName }}
        backendContainer: $(selectedVG_varbackendAzureRmContainerName)
        backendKey: $(selectedVG_varbackendAzureRmKey)